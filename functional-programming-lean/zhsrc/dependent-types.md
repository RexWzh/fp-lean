# 使用依赖类型进行编程

在大多数静态类型的编程语言中，类型和程序之间存在一个密封的界限。
类型和程序具有不同的语法，在不同的时间使用。
通常，类型在编译时使用，用于检查程序是否遵守某些不变量。
程序在运行时使用，实际执行计算。
当这两者相互作用时，通常是以类型案例操作符的形式，比如“instance-of”检查或者提供类型检查器之前不可用的信息的强制转换操作符，以在运行时验证。
换句话说，交互是将类型插入程序世界中，获得一些有限的运行时意义。

Lean 不会强制执行这种严格的分离。
在 Lean 中，程序可以计算类型，类型也可以包含程序。
将程序放置在类型中允许它们的完全计算能力在编译时使用，而将类型从函数中返回使得类型成为编程过程中的一等参与者。

_依赖类型_ 是包含非类型表达式的类型。
一个常见的使用依赖类型的来源是函数的命名参数。
例如，函数 `natOrStringThree` 根据传入的 `Bool` 的不同，返回一个自然数或一个字符串：

```lean
{{#example_decl Examples/DependentTypes.lean natOrStringThree}}
```

依赖类型的更多示例包括：
* [多态的介绍部分](getting-to-know/polymorphism.md) 包含了 `posOrNegThree`，其中函数的返回类型取决于参数的值。
* [OfNat 类型类](type-classes/pos.md#literal-numbers) 取决于所使用的具体自然数字面量。
* [在验证器的示例中使用的 CheckedInput 结构](functor-applicative-monad/applicative.md#validated-input) 取决于验证发生的年份。
* [子类型](functor-applicative-monad/applicative.md#subtypes) 包含与特定值有关的命题。
* 基本上所有有趣的命题，包括决定 [数组索引符号的有效性](props-proofs-indexing.md) 的命题，都是包含值的类型，因此是依赖类型。

依赖类型极大地增加了类型系统的能力。
返回类型根据参数值的分支灵活性使得编写其他类型系统中难以赋予类型的程序成为可能。
同时，依赖类型允许类型签名限制函数返回的哪些值，从而在编译时强制执行强不变式。

然而，使用依赖类型进行编程可能相当复杂，需要一整套超越函数式编程的技能。
表达性强的规范可能很难满足，存在着纠缠不清并无法完成程序的真实风险。
另一方面，这个过程可以带来新的理解，可以用一个精炼的类型来表达。
虽然这一章只是涉及了依赖类型编程的皮毛，它是一个深入的主题，值得有一本完整的书来介绍。