# 摘要

## 依赖类型

依赖类型在类型系统中引入了非类型代码（如函数调用和普通的数据构造）。这样可以大大增加类型系统的表达能力。从参数的值中计算类型的能力意味着函数的返回类型可以根据提供的参数的不同而变化。例如，可以使数据库查询的结果类型依赖于数据库的模式和特定的查询，而无需对查询结果进行任何可能失败的类型转换操作。当查询发生变化时，生成的类型也会随之改变，从而实现立即的编译时反馈。

当函数的返回类型依赖于一个值时，对该值进行模式匹配分析可能会导致类型被“精细化”，因为表示值的变量会被模式中的构造函数替换。函数的类型签名记录了返回类型如何依赖于参数值，而模式匹配则解释了如何为每个潜在的参数提供返回类型。

类型中出现的普通代码在类型检查期间运行，但不调用可能会无限循环的 `partial` 函数。大多数情况下，该计算遵循我们在[本书开篇](../getting-to-know/evaluating.md)中介绍的普通求值规则，即表达式逐步被它们的值替换，直到找到最终值为止。类型检查期间的计算与运行时计算有一个重要的区别：类型中的一些值可能是尚未知道的变量。在这些情况下，模式匹配会“卡住”，不会继续执行，直到选择了特定的构造函数，例如通过模式匹配。类型级别的计算可以看作是一种偏函数求值，在这种求值中只有部分已知的程序部分需要求值，而其他部分则保持不变。

## 宇宙模式

在使用依赖类型时，一种常见的模式是将类型系统的某个子集进行分割。例如，一个数据库查询库可能能够返回可变长度的字符串、固定长度的字符串或特定范围内的数字，但它永远不会返回函数、用户定义的数据类型或 `IO` 操作。可以通过首先定义一个与所需类型结构匹配的构造函数的数据类型，然后定义一个函数，将这个数据类型的值解释为真实的类型，从而定义类型系统的特定领域子集。
构造函数被称为所讨论类型的 _代码_，整个模式有时被称为 _Tarski 风格的宇宙_，或者当上下文明确指出不是指 `Type 3` 或 `Prop` 这样的宇宙时，只被称为 _宇宙_。

自定义宇宙是定义一个类型类并为每个感兴趣的类型定义实例的替代方法。类型类是可扩展的，但并不总是需要可扩展性。与直接使用这些类型相比，定义自定义宇宙有许多优点：
* 递归代码可以实现适用于宇宙中的 _任何_ 类型的通用操作，如相等性测试和序列化。
* 所接受的外部系统类型可以被精确地表示，并且代码数据类型的定义有助于文件明确它的预期。
* Lean 的模式匹配完备性检查器可确保没有遗漏代码，而基于类型类的解决方案则将缺少实例的错误推迟到客户端代码。

## 索引族

数据类型可以接受两种不同类型的参数：_参数_ 在数据类型的每个构造函数中都是相同的，而_索引_ 在构造函数之间可能有所不同。对于给定的索引选择，数据类型的只有一些构造函数是可以使用的。例如，只有当长度索引为 `0` 时，`Vect.nil` 才可用；而只有当长度索引为 `n+1`（其中 `n` 是一个整数）时，`Vect.cons` 才可用。虽然参数通常被写成在数据类型声明中冒号之前的命名参数，索引通常被写成在冒号之后的函数类型的参数，但 Lean 可以推断出冒号之后的参数被用作参数。

索引族允许表达数据之间的复杂关系，并由编译器进行检查。数据类型的不变条件可以直接编码，而且无法违反这些条件，甚至是暂时的。通过向编译器提供关于数据类型的不变条件的信息，可以带来重要的好处：编译器现在可以告诉程序员必须采取什么措施来满足这些条件。通过编译时错误的策略性使用，特别是由下划线产生的错误，可以将一些编程思维过程转移到 Lean 上，从而让程序员解放出心智去考虑其他事情。

使用索引族编码不变条件可能会带来困难。首先，每个不变条件都需要自己的数据类型，这就需要自己的支持库。`List.append` 和 `Vect.append` 显然不能互换使用。
这会导致代码重复。
其次，方便使用索引族要求在类型检查中使用的函数的递归结构与程序的递归结构相匹配。编程时，要做到正确的符合是一门艺术。
虽然可以通过使用等式证明来弥补缺失的符合，但这很困难，而且会导致程序中充满了晦涩的证明。
第三，对大值进行复杂代码的类型检查可能导致编译时的减速。
对于复杂的程序，避免这些减速可能需要专门的技术。

## 定义和命题相等

Lean的类型检查器偶尔需要检查两个类型是否可以互换。因为类型可以包含任意程序，所以必须能够检查任意程序的相等性。然而，没有一种有效的算法可以检查任意程序的完全一般的数学相等性。为了解决这个问题，Lean包含了两种相等性的概念：

* _定义相等_ 是一个对相等进行近似的概念，基本上检查语法表示的相等性，忽略了计算和绑定变量的重命名。Lean会在需要的情况下自动检查定义相等。

* _命题相等_ 必须由程序员显式证明和显式调用。作为回报，Lean会自动检查证明的有效性以及调用是否达到正确的目标。

这两种相等性的概念代表了程序员和Lean之间的分工。定义相等是简单但自动的，而命题相等是手动的但具有表达能力。命题相等可以用来解决类型中本来无法进行计算的程序。

然而，频繁使用命题相等来解决类型级计算的问题通常是不好的代码风格。这通常意味着巧合没有被很好地设计，通常更好的做法是重新设计类型和索引或者使用其他技术来强制执行所需的不变量。当命题相等被用来证明程序满足规范或作为子类型的一部分时，则没有太多可疑的理由。