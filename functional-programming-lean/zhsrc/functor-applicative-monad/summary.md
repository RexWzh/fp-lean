# 摘要

## 类型类和结构体

在幕后，类型类是由结构体表示的。
定义一个类就是定义一个结构体，并创建一个空的实例表。
定义一个实例就是创建一个具有该结构体作为类型的值，或者是一个可以返回该结构体的函数，并且将一个条目添加到表中。
实例搜索是通过查询实例表来构造实例的过程。
结构体和类都可以为字段提供默认值（即方法的默认实现）。

## 结构体和继承

结构体可以继承自其他结构体。
在幕后，继承的结构体包含了原始结构体的一个实例作为字段。
换句话说，继承是通过组合来实现的。
当使用多重继承时，只使用额外父结构体中的唯一字段，以避免菱形问题，并且通常提取父值的函数改为组织构造一个父结构体。
记录点表示法考虑了结构体继承。

因为类型类只是应用了一些附加自动化的结构体，所以所有这些特性都适用于类型类。
结合默认方法，可以使用这些特性来创建细粒度的接口层次结构，但不会对客户端造成很大负担，因为大类所继承的小类可以自动实现。

## Applicative Functors（应用函子）

应用函子是一种带有两个附加操作的函子：
 * `pure`，与 `Monad` 中的运算符相同
 * `seq`，允许在函子的上下文中应用函数
 
虽然单子可以表示带有控制流的任意程序，但应用函子只能从左到右运行函数参数。
因为它们的功能更弱，所以它们为针对接口编写的程序提供更少的控制，而方法的实现者则更具自由度。
一些有用的类型可以实现 `Applicative`，但却无法实现 `Monad`。

实际上，类型类 `Functor`、`Applicative` 和 `Monad` 构成了一个权力层次结构。
从 `Functor` 向 `Monad` 上升，允许编写更强大的程序，但更少的类型实现更强大的类。
应编写多态程序以使用尽可能弱的抽象，而应将数据类型赋予尽可能强大的实例。
这样可以最大限度地重用代码。
更强大的类型类扩展了更弱的类型类，意味着 `Monad` 的实现会自动提供 `Functor` 和 `Applicative` 的实现。
每个类都有一组需要实现的方法和相应的合同，该合同规定了方法的额外规则。
针对这些接口编写的程序期望遵循额外的规则，如果不遵循这些规则，程序可能会有错误。
在 `Functor` 的默认实现中，使用 `Applicative` 的方法实现，并且在 `Applicative` 的默认实现中，使用 `Monad` 的方法实现，这些实现都将遵守这些规则。

## Universe（宇宙）

为了使 Lean 可以作为编程语言和定理证明器使用，对语言进行了一些限制是必要的。
这包括对递归函数的限制，以确保它们要么终止，要么标记为 `partial` 并写成返回非不可居住类型的形式。
此外，必须无法将某些类型的逻辑悖论表示为类型。

排除某些悖论的限制之一是将每个类型分配给一个 _universe_（宇宙）。
宇宙是诸如 `Prop`、`Type`、`Type 1`、`Type 2` 等类型。
这些类型描述了其他类型 —— 就像 `0` 和 `17` 被 `Nat` 描述一样，`Nat` 本身被 `Type` 描述，`Type` 则被 `Type 1` 描述。
将一个类型作为参数的函数的类型必须是大于参数宇宙的宇宙。

因为每个声明的数据类型都有一个宇宙，所以编写使用类型的代码会很麻烦，需要将每个多态类型复制粘贴，以从 `Type 1` 获取参数。
一个名为 _universe polymorphism_ 的特性允许 Lean 程序和数据类型接受宇宙级别作为参数，就像普通多态允许程序接受类型作为参数一样。
一般来说，Lean 库在实现多态操作的库时应使用宇宙多态。