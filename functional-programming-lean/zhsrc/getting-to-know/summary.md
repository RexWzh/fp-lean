# 概述

## 表达式的求值

在 Lean 中，当表达式被求值时会发生计算。
这遵循数学表达式的常规规则：子表达式按照常规的运算顺序被替换为它们的值，直到整个表达式变为一个值。
在评估 `if` 或 `match` 语句时，分支中的表达式在找到条件或匹配对象的值之前不会被评估。

一旦它们被赋予一个值，变量就不会再改变。
与数学类似但与大多数编程语言不同，Lean 的变量只是值的占位符，而不是可以写入新值的地址。
变量的值可以来自使用 `def` 进行的全局定义，使用 `let` 进行的局部定义，作为函数的命名参数，或来自模式匹配。

## 函数

在 Lean 中，函数是一等值，意味着它们可以作为参数传递给其他函数，保存在变量中，并像任何其他值一样使用。
每个 Lean 函数接受且只接受一个参数。
为了编码接受多个参数的函数，Lean 使用一种称为柯里化（currying）的技术，其中提供第一个参数返回一个期望接收剩余参数的函数。
为了编码不接受参数的函数，Lean 使用了 `Unit` 类型，它是可能的最不具信息的参数。

有三种主要的创建函数的方式：
1. 使用 `fun` 编写匿名函数。
   例如，可以将交换 `Point` 的字段的函数写为 `{{#example_in Examples/Intro.lean swapLambda}}`。
2. 使用圆括号中的一个或多个居中的点 `·` 来编写非常简单的匿名函数。
   每个居中的点都成为函数的一个参数，而括号限定了它的主体。
   例如，将从其参数中减去 one 的函数可以写为 `{{#example_in Examples/Intro.lean subOneDots}}` 而不是 `{{#example_out Examples/Intro.lean subOneDots}}`。
3. 使用 `def` 或 `let` 进行函数定义，可以通过添加参数列表或使用模式匹配的语法。

## 类型

Lean 检查每个表达式是否具有类型。
类型，如 `Int`、`Point`、`{α : Type} → Nat → α → List α` 和 `Option (String ⊕ (Nat × String))`，描述了可能最终找到的表达式的值。
与其他语言一样，Lean 中的类型可以表达程序的轻量级规范，并由 Lean 编译器进行检查，从而省去了某些类型的单元测试的需要。
与大多数语言不同的是，Lean 的类型可以表示任意的数学概念，将编程和定理证明的世界统一起来。
虽然在这本书中，我们主要不会使用 Lean 来证明定理，但是《Theorem Proving in Lean 4》这本书中包含了更多关于这一主题的信息。

有些表达式可以有多个类型。
例如，`3` 可以是一个 `Int` 或者一个 `Nat`。
在 Lean 中，应该将其理解为两个不同的表达式，一个类型是 `Nat`，另一个类型是 `Int`，它们恰巧使用了相同的写法，而不是将它们看作是同一个东西的不同类型。

Lean 有时可以自动推断类型，但是用户通常需要提供类型信息。
这是因为 Lean 的类型系统非常灵活。
即使 Lean 能够找到一个类型，它可能不是我们想要的类型 —— 如果没有进一步的约束条件，`3` 可能被认为是一个 `Nat`，而不是一个 `Int`。
一般来说，最好是明确地写出大部分类型，只有非常明显的类型可以让 Lean 自动推导。
这有助于改进 Lean 的错误信息，并使程序员的意图更加清晰。

有些函数或数据类型接受类型作为参数。
它们被称为 _多态_。
多态使得编写像计算列表长度这样的程序时，不需要关心列表中的元素的具体类型。
由于 Lean 中的类型是一等公民，多态不需要任何特殊的语法，因此类型可以像其他参数一样传递。
在函数类型中给参数命名可以使后面的类型引用到该参数，并且将该函数应用到一个参数上的类型可以通过用参数的值替换参数的名称来确定。

## 结构体和归纳类型

Lean 可以使用 `structure` 或 `inductive` 特性引入全新的数据类型。
即使其定义完全相同，这些新类型也不被认为与任何其他类型等价。
数据类型有 _构造函数_ 来解释如何构造其值，并且每个构造函数都接受一定数量的参数。
在 Lean 中，构造函数与面向对象语言中的构造函数不同：Lean 的构造函数是惰性的数据持有者，而不是初始化已分配对象的活动代码。

通常情况下，`structure` 用于引入一个积类型（即只有一个构造函数且可以接受任意数量参数的类型），而 `inductive` 用于引入一个和类型（即有多个不同的构造函数的类型）。
使用 `structure` 定义的数据类型会为构造函数的每个参数提供一个访问函数。结构和归纳数据类型都可以使用模式匹配进行消耗，模式匹配使用了一部分调用构造函数的语法来暴露存储在构造函数中的值。模式匹配意味着知道如何创建一个值就意味着知道如何消耗它。

递归

在定义中，当所定义的名称在其定义自身中使用时，该定义就是递归的。由于 Lean 既是交互式定理证明器又是编程语言，对递归定义有一些限制。
在 Lean 的逻辑方面，循环定义可能会导致逻辑不一致。

为了确保递归定义不破坏 Lean 的逻辑方面，Lean 必须能够证明所有递归函数在调用任何参数时都终止。实际上，这意味着递归调用都在输入的结构较小的部分上进行，这确保了始终向基本情况的进展，或者用户必须提供一些其他证据来证明函数始终终止。同样，递归归纳类型不允许具有将函数作为参数接收的构造函数，因为这将使得编码非终止函数成为可能。