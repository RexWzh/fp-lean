# 附加便利性

## 嵌套动作

在`feline`中的许多函数展示了一种重复的模式，在该模式中，一个`IO`动作的结果被命名，并且立即且仅一次地使用。
例如，在`dump`中：

```lean
{{#include ../../../examples/feline/2/Main.lean:dump}}
```

模式适用于 `stdout` ：

```lean
{{#include ../../../examples/feline/2/Main.lean:stdoutBind}}
```

类似的，`fileStream` 包含以下代码片段：

```lean
{{#include ../../../examples/feline/2/Main.lean:fileExistsBind}}
```

当 Lean 编译 `do` 块时，由左箭头立即接在括号下方的表达式被提升到最近的封闭 `do` 中，并且它们的结果被绑定到一个唯一的名称上。
这个唯一的名称替换了表达式的原始部分。
这意味着 `dump` 也可以被写成以下形式：

```lean
{{#example_decl Examples/Cat.lean dump}}
```

这个版本的 `dump` 避免引入只使用一次的名称，这可以极大简化程序。
Lean 从嵌套表达式上提取的 `IO` 动作称为 _嵌套动作_。

可以使用相同的技巧来简化 `fileStream`：

```lean
{{#example_decl Examples/Cat.lean fileStream}}
```

在这种情况下，使用嵌套操作也可以消除 `handle` 的本地名称，但是最终的表达式会变得长而复杂。
尽管使用嵌套操作通常是很好的风格，但有时候给中间结果命名仍然有帮助。

然而，重要的是要记住，嵌套操作只是在周围的 `do` 块中发生的 `IO` 操作的一种更简短的表示。
执行这些操作涉及的副作用仍然按顺序发生，副作用的执行不会与表达式的求值交错。
为了说明这可能会引起困惑的示例，请考虑以下帮助函数的定义，这些函数在执行后向世界宣告自己已被执行并返回数据：

```lean
{{#example_decl Examples/Cat.lean getNumA}}

{{#example_decl Examples/Cat.lean getNumB}}
```

这些定义旨在代替更复杂的 `IO` 代码，这些代码可能会验证用户输入、读取数据库或打开文件。

一个打印数值 `A` 是 五 时输出 `0`，否则输出数值 `B` 的程序可以按照以下方式编写：

```lean
variables (A B : ℕ)

def program (A B : ℕ) : ℕ :=
  if A = 5 then 0 else B

#eval program A B -- 在这里替换 A 和 B 的具体数值进行测试
```

在这个程序中，变量 `A` 和 `B` 都是自然数类型（`ℕ`），通过 `if` 语句判断 `A` 是否等于 5，如果等于则返回 0，否则返回 `B`。最后，通过 `#eval` 执行函数并输出结果。

```lean
{{#example_decl Examples/Cat.lean testEffects}}
```

然而，该程序可能会产生比预期更多的副作用（例如提示用户输入或读取数据库）。
`getNumA` 的定义明确表示它会始终返回 `5`，因此程序不应该读取数字 B。
然而，运行程序的结果为：

```output info
{{#example_out Examples/Cat.lean runTest}}
```

`getNumB` 函数被执行是因为 `test` 等同于以下定义：

```python
test = LEAN_axioms |- ∀ a b c : ℝ, (∀ ε : ℝ, 0 < ε → ε < (b - a) → (∃ N : ℕ, ∀ n : ℕ, n ≥ N → |(NormalizeRationalR(n) - (b - a))| < ε)) → (∃ N : ℕ, ∀ n : ℕ, n ≥ N → |(NormalizeRationalR(n) - (b - a))| < c)
```

其中 `LEARN_axioms` 是 LEAN 系统定义的公理集合，`|=` 表示可推导出，`∀` 表示全称量词，`∃` 表示存在量词，`ℝ` 表示实数，`ℕ` 表示自然数，`|...|` 表示绝对值。

```lean
{{#example_decl Examples/Cat.lean testEffectsExpanded}}
```

这是因为嵌套的动作被提升到最近的封闭的 `do` 块的规则。
`if` 的分支不会被隐式地包裹在 `do` 块中，因为 `if` 本身不是 `do` 块中的语句——语句是定义 `a` 的 `let` 语句。
事实上，它们不能以这种方式被包裹，因为条件表达式的类型是 `Nat`，而不是 `IO Nat`。

## 灵活的 `do` 布局

在 Lean 中，`do` 表达式对空白敏感。
`do` 中的每个 `IO` 动作或局部绑定都应该从新行开始，并且它们应该具有相同的缩进。
几乎所有使用 `do` 的情况都应该以这种方式书写。
但在一些罕见的上下文中，可能需要手动控制空白和缩进，或者将多个小动作写在一行中可能更方便。
在这些情况下，可以用分号代替换行符，并用大括号代替缩进。

例如，以下所有程序是等价的：

```lean
{{#example_decl Examples/Cat.lean helloOne}}

{{#example_decl Examples/Cat.lean helloTwo}}

{{#example_decl Examples/Cat.lean helloThree}}
```

Idiomatic Lean 代码很少使用带有 `do` 的大括号。

## 使用 `#eval` 运行 `IO` 动作

Lean 的 `#eval` 命令可以用于执行 `IO` 动作，而不仅仅是对其进行求值。
通常，将 `#eval` 命令添加到 Lean 文件中会使 Lean 对所提供的表达式进行求值，将得到的值转换为字符串，并将该字符串作为提示信息和在信息窗口中提供。
而不是因为 `IO` 动作无法转换为字符串而失败，`#eval` 执行它们，执行它们的副作用。
如果执行结果是 `Unit` 值 `()`，则不显示结果字符串，但如果它是可以转换为字符串的类型，则 Lean 显示结果值。

这意味着，给定了 `countdown` 和 `runActions` 的之前的定义，

```lean
{{#example_in Examples/HelloWorld.lean evalDoesIO}}
```

# LEAN 定理证明

## 引言
在数学和计算机科学中，定理证明是一种通过逻辑推理和推演来证明数学命题的方法。LEAN 是一个用于形式化定理证明的交互式证明工具。本文将介绍 LEAN 定理证明的基本概念和方法。

## LEAN 的基本概念
- **引理（lemma）**：是一个中间步骤或辅助命题，用于证明其他更复杂的命题。在 LEAN 中，引理是通过一系列命题和推理规则来构建的。
- **定理（theorem）**：是一个经过证明的命题。定理通常是问题的解决方案或重要结论。
- **证明（proof）**：是一种推导过程，用于推断一个命题的真实性。证明的目标是通过一系列逻辑推理来建立一个命题的真实性。
- **推理规则（inference rules）**：是一套指导证明过程的规则。推理规则用于从已知命题中导出新的命题。

## LEAN 定理证明的步骤
1. 定义问题：首先，定义问题的目标和假设。
2. 转化问题：将问题转化为逻辑表达式，引入新的符号和术语。
3. 构建证明：通过引理和推理规则构建证明的步骤。每个步骤都需要明确陈述命题和推理规则，并提供相应的证明步骤。
4. 完成证明：当所有步骤都完成时，整理证明并检查证明是否完整和正确。
5. 检查证明：使用 LEAN 工具检查证明的正确性和完整性。LEAN 提供了自动验证证明的功能。

## 例子
为了更好地理解 LEAN 定理证明的过程，下面是一个简单的例子。

**问题**：证明对于所有正整数 n，n^2 + n + 41 是一个素数。

首先，我们引入一个辅助命题：

**引理 1**：如果 n 是一个正整数，则 n^2 + n + 41 是一个奇数。

**证明引理 1**：根据数学上的定义，奇数加奇数等于偶数，偶数加偶数等于偶数，奇数加偶数等于奇数。因此，n^2 + n 总是一个偶数，所以 n^2 + n + 41 是一个奇数。

使用引理 1，我们可以证明原始问题：

**定理**：对于所有正整数 n，n^2 + n + 41 是一个素数。

**证明**：根据引理 1，n^2 + n + 41 是一个奇数。根据奇数的定义和质数的定义，我们可以推断出 n^2 + n + 41 是一个素数。

该证明过程可以通过 LEAN 工具进行自动验证，并且可以用于证明其他复杂的数学问题。

## 结论
LEAN 是一个强大的定理证明工具，它提供了一种形式化证明的方法。通过使用引理、推理规则和逻辑推理，LEAN 能够帮助数学家和计算机科学家证明各种命题和定理。

```output info
{{#example_out Examples/HelloWorld.lean evalDoesIO}}
```

这是通过运行 `IO` 动作产生的输出，而不是动作本身的不透明表示方式。
换句话说，对于 `IO` 动作，`#eval` 同时 _评估_ 提供的表达式和 _执行_ 结果动作值。

使用 `#eval` 快速测试 `IO` 动作比编译和运行整个程序更方便。
然而，这也存在一些限制。
例如，从标准输入读取只会返回空输入。
此外，每当 Lean 需要更新提供给用户的诊断信息时，`IO` 动作会被重新执行，而这可能发生在不可预测的时间。
例如读写文件的动作可能会在不方便的时候执行。