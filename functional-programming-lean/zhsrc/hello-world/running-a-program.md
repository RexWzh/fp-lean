# 运行程序

运行 Lean 程序最简单的方法是使用 Lean 可执行文件的 `--run` 选项。
创建一个名为 `Hello.lean` 的文件，并输入以下内容：

```lean
{{#include ../../../examples/simple-hello/Hello.lean}}
```

然后，从命令行运行：

```
{{#command {simple-hello} {hello} {lean --run Hello.lean} }}
```

该程序显示 `{{#command_out {hello} {lean --run Hello.lean} }}` 并退出。

## 问候的解剖

当使用 `--run` 选项调用 Lean 时，它会调用程序的 `main` 定义。
在不接受命令行参数的程序中，`main` 的类型应该是 `IO Unit`。
这意味着 `main` 不是一个函数，因为它的类型中没有箭头(`→`)。
`main` 不是一个具有副作用的函数，而是一个关于要执行效果的描述。

如[前一章节](../getting-to-know/polymorphism.md)中所讨论的，`Unit` 是最简单的归纳类型。
它有一个名为 `unit` 的构造函数，不带任何参数。
在 C 语言家族的语言中，有一个名为 `void` 的函数类型，它不返回任何值。
在 Lean 中，所有函数都会接受一个参数并返回一个值，如果没有有趣的参数或返回值，则可以使用 `Unit` 类型来表示。
如果 `Bool` 表示一个单一的信息位，那么 `Unit` 表示零个信息位。

`IO α` 是一个程序的类型，当执行它时，它将抛出异常或返回一个类型为 `α` 的值。
在执行过程中，该程序可能会产生副作用。
这些程序被称为 `IO` _操作_。
Lean区分表达式的_求值_和`IO`操作的_执行_。求值严格遵循数学模型，将值替换为变量并减少子表达式而没有副作用，而`IO`操作的执行依赖于与外部系统的交互。
`IO.println` 是一个从字符串到 `IO` 操作的函数，当执行时，它将给定的字符串写入标准输出。
因为此操作在发出字符串时不从环境中读取任何有趣的信息，所以 `IO.println` 的类型为 `String → IO Unit`。
如果它返回了一些有趣的信息，那么这将通过 `IO` 操作的类型不是 `Unit` 来表示。

## 函数式编程与效果

Lean 的计算模型是基于对数学表达式的求值，其中变量在时间上给定一个确定的值。
对一个表达式求值的结果不会发生变化，再次对同一表达式求值总是会得到相同的结果。

另一方面，有用的程序必须与世界进行交互。
一个不执行输入或输出的程序不能向用户请求数据，创建磁盘文件，或者打开网络连接。
Lean 使用它自身编写，Lean 编译器肯定会读取文件，创建文件，并与文本编辑器交互。
当存储在文件中的内容随时间变化时，一个总是将产生相同结果的表达式如何支持从磁盘读取文件的程序呢？

通过以不同的方式思考副作用，这个表面上的矛盾可以解决。
想象一个咖啡厅，它出售咖啡和三明治。
这个咖啡厅有两个员工：一个厨师负责制作订单，还有一个在柜台上与顾客交互并下订单。
厨师是一个满腹牢骚的人，他真的不喜欢与外界有任何联系，但是他非常擅长始终如一地制作咖啡和饮料，这也是咖啡厅所以闻名。
然而，为了做到这一点，厨师需要安静，不能被打扰。

柜台工作人员很友善，但在厨房方面完全无能。
顾客与柜台工作人员交互，柜台工作人员将真正的烹饪工作委托给了厨师。
如果厨师对顾客有疑问，比如澄清过敏问题，他们会给柜台工作人员发一个小纸条，由柜台工作人员与顾客交流，并用纸条将结果传递回给厨师。

在这个类比中，厨师就是 Lean 语言。
当提供了一个订单，厨师忠实地和始终如一地提供所请求的食物。
柜台工作人员是周围的运行时系统，可以与外界交互，接受付款，提供食物，并与顾客交谈。
两个员工共同工作，完成了餐厅的所有功能，但他们各自负责自己擅长的任务。
就像将顾客隔离起来可以让厨师专注于制作真正优质的咖啡和三明治一样，Lean 的无副作用特性允许程序作为形式化数学证明的一部分来使用。
这也帮助程序员理解程序的各个部分，因为没有隐藏的状态变化会在组件之间创建微妙的耦合。
厨师的纸条代表通过评估 Lean 表达式产生的 `IO` 动作，柜台工作人员的回复则是从效果中传回的值。

这种副作用的模型与 Lean 语言、它的编译器和运行时系统(RTS)的总体聚合之间的工作方式非常相似。
运行时系统中的基本效果由 C 编写的原语实现。
当运行一个程序时，运行时系统（RTS）调用 `main` 动作，该动作返回新的 `IO` 动作给 RTS 执行。
RTS 执行这些动作，委托用户的 Lean 代码来执行计算。
从 Lean 的内部角度来看，程序是没有副作用的，`IO` 动作只是要执行的任务描述。
从程序用户的外部角度来看，有一层副作用，它们创建了程序核心逻辑的接口。


## 真实世界的函数式编程

另一种有用的思考 Lean 中副作用的方式是将 `IO` 动作视为将整个世界作为参数并返回与新世界成对的值的函数。
在这种情况下，从标准输入读取一行文本是一个纯函数，因为每次都会提供一个不同的世界作为参数。
向标准输出写入一行文本是一个纯函数，因为该函数返回的世界与开始时的世界不同。
程序需要小心，永远不要重用世界，也不要忘记返回一个新世界——毕竟这会导致时间旅行或世界的末日。
仔细的抽象边界可以保证这种编程风格的安全性。
如果每个基本的 `IO` 动作接受一个世界并返回一个新的世界，并且它们只能与保持这个不变量的工具组合，那么问题就不会发生。

这种模型无法实现。
毕竟，整个宇宙无法变成一个 Lean 值并放入内存中。
然而，可以使用一个代表世界的抽象标记来实现这种模型的变体。
当程序启动时，它会提供一个世界标记。
然后将此标记传递给 IO 原语，它们返回的标记同样传递给下一步。
在程序结束时，将标记返回给操作系统。

这种副作用模型很好地描述了在 Lean 中内部表示 `IO` 动作作为 RTS 要执行的任务描述的方式。
实际上将真实世界转换为 Lean 值并隐藏在一个抽象屏障之后。
但实际程序通常由一系列效果组成，而不仅仅是一个效果。
为了使程序能够使用多个效果，Lean 中有一个被称为 `do` 记法的子语言，允许将这些基本的 `IO` 动作安全地组合成一个更大、更有用的程序。
## 组合 IO 动作

大多数有用的程序除了产生输出外，还接受输入。
此外，它们可能会根据输入做出决策，并将输入数据作为计算的一部分。
下面的程序称为 `HelloName.lean`，它会询问用户的姓名，然后给出问候：

```lean
{{#include ../../../examples/hello-name/HelloName.lean:all}}
```

在这个程序中，`main` 动作由一个 `do` 块组成。
这个块包含一系列的 *语句*，这些语句可以是 *局部变量*（使用 `let` 引入）和要执行的动作。
就像 SQL 被认为是一种用于与数据库交互的特殊目的语言一样，`do` 语法可以被认为是 Lean 中专门用于建模命令式程序的特殊子语言。
使用 `do` 块构建的 `IO` 动作会按顺序执行语句。

这个程序可以以与前一个程序相同的方式运行：

```
{{#command {hello-name} {hello-name} {./run} {lean --run HelloName.lean}}}
```

如果用户回答“David”，则和程序进行的一个交互会话如下所示：

```python
user: David
program: Hello David! How can I assist you today?
```

```
{{#command_out {hello-name} {./run} }}
```

类型签名行就像 `Hello.lean` 中的一样：

```lean
{{#include ../../../examples/hello-name/HelloName.lean:sig}}
```

唯一的区别是它以关键词 `do` 结尾，该关键词启动一个命令序列。
`do` 后面的每一行缩进的代码都属于同一个命令序列。

前两行为:

```lean
{{#include ../../../examples/hello-name/HelloName.lean:setup}}
```

通过执行库操作 `IO.getStdin` 和 `IO.getStdout`，检索 `stdin` 和 `stdout` 句柄。
在 `do` 块中，`let` 的意义与普通表达式中稍有不同。
通常，`let` 中的局部定义只能在紧随其后的一个表达式中使用。
在 `do` 块中，由 `let` 引入的局部绑定在 `do` 块的剩余语句中都是可用的，而不仅仅是下一个。
此外，`let` 通常使用 `:=` 将正在定义的名称与其定义连接起来，而 `do` 块中的某些 `let` 绑定使用箭头 (`←` 或 `<-`)。
使用箭头表示表达式的值是一个应该执行的 `IO` 操作，并将操作的结果保存在局部变量中。
换句话说，如果箭头右侧的表达式类型为 `IO α`，那么变量在 `do` 块的剩余部分中具有类型 `α`。
为了允许在程序中本地覆盖 `stdin` 和 `stdout`，`IO.getStdin` 和 `IO.getStdout` 是 `IO` 操作，这是很方便的。
如果它们像 C 语言中的全局变量一样，就没有有意义地覆盖它们的方式了，但是 `IO` 操作每次执行时都可以返回不同的值。

`do` 块的下一部分负责询问用户的姓名：

```lean
{{#include ../../../examples/hello-name/HelloName.lean:question}}
```

第一行向 `stdout` 写入问题，第二行从 `stdin` 请求输入，第三行从输入行中删除尾随换行符（以及任何其他尾随空格）。
`name` 的定义使用 `:=`，而不是 `←`，因为 `String.dropRightWhile` 是字符串上的普通函数，而不是 `IO` 动作。

最后，程序的最后一行是：

```
{{#include ../../../examples/hello-name/HelloName.lean:answer}}
```

它使用[字符串插值](../getting-to-know/conveniences.md#string-interpolation)将提供的名称插入到问候字符串中，并将结果写入到 `stdout` 中。