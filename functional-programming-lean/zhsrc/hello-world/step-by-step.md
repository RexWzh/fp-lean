# 一步一步

`do` 块可以逐行执行。
首先从前一节的程序开始：

```lean
{{#include ../../../examples/hello-name/HelloName.lean:block1}}
```

## 标准输入输出

第一行是 `{{#include ../../../examples/hello-name/HelloName.lean:line1}}`，而剩下的部分是：

```lean
{{#include ../../../examples/hello-name/HelloName.lean:block2}}
```

为了执行使用 “←” 的 `let` 语句，首先要评估箭头右侧的表达式（在这里是 `IO.getStdIn`）。
由于这个表达式只是一个变量，它的值会被查找。
得到的值是一个内置的原始 `IO` 动作。
下一步是执行这个 `IO` 动作，得到表示标准输入流的值，其类型是 `IO.FS.Stream`。
然后，将标准输入与箭头左侧的名称（这里是 `stdin`）关联，供 `do` 块的其余部分使用。

执行第二行 `{{#include ../../../examples/hello-name/HelloName.lean:line2}}` 的过程类似。
首先，评估表达式 `IO.getStdout`，得到一个将返回标准输出的 `IO` 动作。
然后，执行这个动作，实际上返回标准输出。
最后，将这个值与名称 `stdout` 关联，供 `do` 块的其余部分使用。

## 提出问题

现在找到了 `stdin` 和 `stdout`，块的其余部分包括一个问题和一个答案：

```lean
{{#include ../../../examples/hello-name/HelloName.lean:block3}}
```

该块中的第一个语句 `{{#include ../../../examples/hello-name/HelloName.lean:line3}}` 是一个表达式。
要执行一个表达式，首先需要对其进行求值。
在本例中，`IO.FS.Stream.putStrLn` 的类型为 `IO.FS.Stream → String → IO Unit`。
这意味着它是一个接受一个流和一个字符串，返回一个 `IO` 动作的函数。
该表达式使用了[访问符记法](../getting-to-know/structures.md#behind-the-scenes)进行函数调用。
该函数应用于两个参数：标准输出流和一个字符串。
该表达式的值是一个 `IO` 动作，它将字符串和换行符写入输出流。
找到这个值后，下一步是执行它，这会导致字符串和换行符实际被写入到 `stdout`。
只包含表达式的语句不引入任何新的变量。

该块中的下一个语句是 `{{#include ../../../examples/hello-name/HelloName.lean:line4}}`。
`IO.FS.Stream.getLine` 的类型为 `IO.FS.Stream → IO String`，这意味着它是一个从流到 `IO` 动作的函数，该动作将返回一个字符串。
同样，这是一个访问符记法的示例。
该 `IO` 动作被执行，程序会等待用户输入完整的一行。
假设用户输入 "`David`"。
生成的行为(`"David\n"`)与 `input` 相关联，其中转义序列 `\n` 表示换行符。

```lean
{{#include ../../../examples/hello-name/HelloName.lean:block5}}
```

下一行，`{{#include ../../../examples/hello-name/HelloName.lean:line5}}`，是一个 `let` 语句。
与程序中的其他 `let` 语句不同，它使用了 `:=` 而不是 `←`。
这意味着表达式将被求值，但得到的值不一定是一个 `IO` 动作，也不会被执行。
在这种情况下，`String.dropRightWhile` 接受一个字符串和一个字符谓词，并返回一个新的字符串，其中满足谓词的字符已被删除。
例如，

```lean
{{#example_in Examples/HelloWorld.lean dropBang}}
```

# LEAN 定理证明

## 引言

LEAN 定理证明是一种基于依赖类型理论的集成式证明工具，它是由法国国家科学研究中心（CNRS）和英国华威大学联合开发的。LEAN 提供了一种形式化证明的框架，有助于在数学和计算机科学领域中构建可靠的证明。

## LEAN 的特点

- **交互式证明**：LEAN 具有交互式的证明过程，使得用户可以逐步构建证明。用户输入的每个步骤都会得到系统的实时反馈和验证。

- **高度可靠**：理论证明结构在 LEAN 中被严格定义和验证。此外，LEAN 还提供了检查证明正确性的工具。

- **自动化证明**：LEAN 使用自动化技术帮助用户简化证明过程。它包括决策过程、自动类型推断和自动证明搜索等功能。

## LEAN 定理证明的工作流程

LEAN 的证明过程由一系列的定理、引理和证明步骤组成。以下是 LEAN 定理证明的一般工作流程：

1. **定义**：用户首先定义问题的基本概念和术语，包括需要证明的定理和相关的引理。这些定义必须遵循依赖类型理论的语法和规则。

2. **证明步骤**：用户使用 LEAN 的交互式环境逐步构建证明过程。每个证明步骤都需要给出明确的证明策略。LEAN 的自动化功能可以帮助用户生成证明的部分或全部步骤。

3. **验证**：一旦用户完成了整个证明过程，LEAN 会对证明进行验证。系统会检查每个步骤是否按照规则定义，以及是否满足依赖类型理论的要求。如果验证通过，证明被视为有效。否则，用户需要修复证明中的错误。

4. **发布和共享**：完成验证后，用户可以将证明结果发布和共享给其他用户或社区。这有助于进一步的研究和验证。

LEAN 的特性使得它在数学、计算机科学和形式化验证领域中被广泛使用。它不仅提供了一个强大的工具来证明数学定理，而且还促进了证明的可复用性和可扩展性。

## 结论

LEAN 定理证明提供了一种强大而灵活的方法来进行形式化证明。它结合了交互性、可靠性和自动化技术，为数学家、计算机科学家和形式化验证专家提供了一个有力的工具。LEAN 的发展使得证明过程更加透明、容易理解和验证，有助于提高证明的可信度和正确性。

```output info
{{#example_out Examples/HelloWorld.lean dropBang}}
```

# LEAN 定理证明

## 引言

LEAN 是一种交互式定理证明工具，它基于依赖类型理论。它被设计为通用的证明助手，可以用于验证各种数学定理的正确性。它的核心思想是利用计算机来辅助人类进行证明，提高证明的可靠性和可重用性。

在本文中，我们将详细解释 LEAN 定理证明的原理和过程。我们将使用一个简单的例子来说明如何使用 LEAN 来证明一个数学定理。

## LEAN 定理证明的过程

1. 设定目标：在 LEAN 中，一个证明的起点是设定目标，也就是要证明的命题。例如，我们要证明：对于任意的自然数 n，n + 0 = n。

2. 建立证明：通过一系列的推理步骤，我们可以建立一个证明。在 LEAN 中，我们可以使用逻辑运算符和数学公理来进行推理。例如，在这个例子中，我们可以使用加法的定义和加法的性质来推导出结论。

   - 使用加法的定义：n + 0 = n，我们可以将 n + 0 替换为 n。
   - 使用加法的性质：n = n，这是一个恒等式，可以直接应用。

   经过一系列的推理步骤，我们可以得出结论：对于任意的自然数 n，n + 0 = n。

3. 检查证明：在建立证明之后，需要对证明进行检查，以确保证明的正确性。在 LEAN 中，可以使用计算机来检查证明的每一个步骤是否正确。通过检查，我们可以验证证明的正确性。

## 总结

LEAN 是一种交互式的定理证明工具，它可以用于验证数学定理的正确性。它的核心思想是使用计算机来辅助进行证明，并提供可靠和可重用的证明过程。通过设定目标和建立证明的过程，我们可以使用 LEAN 来证明各种数学定理。最后，我们可以使用计算机来检查证明的正确性，以增加证明的可靠性。

```lean
{{#example_in Examples/HelloWorld.lean dropNonLetter}}
```

得到

# LEAN 定理证明

在证明定理时，我们通常使用逻辑推理和数学推导来推导出结论。然而，人们对于这些推导的正确性并不总是有信心。为了解决这个问题，计算机科学家们发展了一种称为形式化证明的方法，可以使用计算机来检查证明的正确性。

其中一种受到广泛使用的形式化证明工具是 LEAN。LEAN 是一种基于依赖类型理论的交互式证明助手。它提供了一个强大的语言和工具，可用于开发严格的数学证明。通过使用 LEAN，我们可以编写形式化的证明并获得有关正确性的保证。

在 LEAN 中，我们可以定义命题和证明，使用逻辑公理、定义和定理来构建证明。然后可以通过LENA的推理引擎来检查证明的正确性。

LEAN 定理证明的一般过程通常包括以下步骤：

1. 选择要证明的定理。确定要证明的命题或数学问题。
2. 定义相应的符号和概念。为所需的数学对象和操作符定义适当的表示。
3. 构建证明的基础。使用逻辑公理和定义来建立证明的起点。
4. 进行推导规则的应用。使用推理规则和定义逐步推导出证明的主体。
5. 审查和验证证明。检查证明的每一步是否正确，并验证推理的有效性。
6. 完成并提交证明。最终确认证明的正确性，将证明提交给其他人审查。

在使用 LEAN 进行定理证明时，需要遵循严格的逻辑和推理规则，并确保每一步的正确性。通过使用 LEAN，我们可以确保证明方法的可靠性，并且可以自动检查证明的正确性。

使用 LEAN 进行定理证明可以帮助我们加强对证明的信心，并促进数学推理的自动化和标准化。这为数学和计算机科学的研究领域带来了许多前所未有的机会和挑战。

```output info
{{#example_out Examples/HelloWorld.lean dropNonLetter}}
```

在程序的当前行中，将输入字符串的右侧删除了所有非字母数字字符，得到了 "David"，与 `name` 相关联，直到该代码块结束。

## 向用户致以问候

在 `do` 代码块中只剩下一个语句需要执行：

```lean
{{#include ../../../examples/hello-name/HelloName.lean:line6}}
```

`putStrLn`函数的字符串参数是通过字符串插值构造的，得到字符串“Hello, David!”。
因为这个语句是一个表达式，所以它会被求值，得到一个`IO`操作，该操作将打印这个带有换行符的字符串到标准输出。
一旦表达式被求值，生成的`IO`操作就被执行，从而产生了问候。

## 作为值的`IO`操作

在上述描述中，很难看出为什么需要将求值表达式与执行`IO`操作区分开来。
毕竟，每个动作都是在产生后立即执行的。
为什么不像其他语言那样在求值过程中执行效果呢？

答案有两个方面。
首先，将求值与执行分开意味着程序必须明确哪些函数可以具有副作用。
因为没有副作用的程序部分更容易进行数学推理，在程序员的头脑中或使用Lean的正式证明工具时都是如此，这种分离可以更容易地避免错误。
其次，并非所有的`IO`操作都需要在创建时执行。
可以在不执行的情况下提到一个操作，这样普通函数就可以用作控制结构。

例如，函数`twice`接受一个`IO`操作作为参数，返回一个新的操作，该操作将执行第一个操作两次。

```lean
{{#example_decl Examples/HelloWorld.lean twice}}
```

在这种情况下，执行以下操作

```lean
{{#example_in Examples/HelloWorld.lean twiceShy}}
```

导致的结果是：

```output info
{{#example_out Examples/HelloWorld.lean twiceShy}}
```

将被打印的文字。
这可以推广到运行基础操作任意次数的版本：

```lean
{{#example_decl Examples/HelloWorld.lean nTimes}}
```

在 `Nat.zero` 的基本情况下，结果是 `pure ()`。
函数 `pure` 创建了一个没有副作用的 `IO` 动作，但返回 `pure` 的参数，也就是 `Unit` 的构造函数。
作为一个什么都不做并且返回没什么有趣的东西的动作，`pure ()` 同时非常无聊和非常有用。
在递归步骤中，使用 `do` 块创建一个动作，该动作首先执行 `action`，然后执行递归调用的结果。
执行 `{{#example_in Examples/HelloWorld.lean nTimes3}}` 会导致以下输出：

```output info
{{#example_out Examples/HelloWorld.lean nTimes3}}
```

除了使用函数作为控制结构之外，`IO` 操作作为一级值的事实意味着它们可以保存在数据结构中以供以后执行。
例如，函数 `countdown` 接受一个 `Nat` 并返回一个未执行的 `IO` 操作列表，每个 `Nat` 对应一个操作：

```lean
{{#example_decl Examples/HelloWorld.lean countdown}}
```

这个函数没有任何副作用，不打印任何东西。
例如，可以将其应用于一个参数，并检查结果动作列表的长度：

```lean
{{#example_decl Examples/HelloWorld.lean from5}}
```

这个列表包含了六个元素（一个用于每个数字，加上一个用于零的`"Blast off!"`动作）：

```lean
{{#example_in Examples/HelloWorld.lean from5length}}
```



```output info
{{#example_out Examples/HelloWorld.lean from5length}}
```

函数 `runActions` 接受一个动作列表，并构造一个按顺序运行它们的单一动作：

```lean
{{#example_decl Examples/HelloWorld.lean runActions}}
```

其结构基本与 `nTimes` 相同，不同之处在于每个 `Nat.succ` 执行的是一个在每个`List.cons` 下执行的动作。
同样，`runActions` 本身并不运行这些动作。
它创建了一个新的动作来运行它们，并且该动作必须放置在一个位置上，以便作为 `main` 中的一部分被执行：

```lean
{{#example_decl Examples/HelloWorld.lean main}}
```

运行这个程序会得到以下输出：

```output info
{{#example_out Examples/HelloWorld.lean countdown5}}
```

当运行这个程序时会发生什么？
第一步是评估 `main` 函数。这个步骤如下进行：

```lean
{{#example_eval Examples/HelloWorld.lean evalMain}}
```

所得的`IO`操作是一个`do`块。
每个`do`块的步骤依次执行，产生预期的输出。
最后一步`pure ()`没有任何效果，只是因为`runActions`的定义需要一个基本情况。

## 练习

在纸上逐步执行以下程序：

```lean
{{#example_decl Examples/HelloWorld.lean ExMain}}
```

在程序执行过程中，要注意识别表达式何时被求值，以及何时执行 `IO` 操作。
当执行 `IO` 操作产生副作用时，要将其记录下来。
完成后，用 Lean 运行程序，并仔细检查关于副作用的预测是否准确。