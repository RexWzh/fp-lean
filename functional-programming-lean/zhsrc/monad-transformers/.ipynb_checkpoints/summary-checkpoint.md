# 概要

## 合并 Monad

在从头开始编写一个 Monad 时，有一些设计模式通常可以描述每种效果添加到 Monad 的方式。
通过将 Monad 的类型定义为来自 Reader 环境的函数，可以添加 Reader 效果；通过将初始状态到与最终状态配对的值的函数包含在中，可以添加状态效果；通过将总和类型包含在返回类型中，可以添加故障或异常；通过在返回类型中包含乘积类型，可以添加记录或其他输出。
现有的 Monad 也可以作为返回类型的一部分，以使其效果包含在新的 Monad 中。

通过定义 _Monad 变换器_，这些设计模式可以组成一个用于可重用软件组件的库，它将效果添加到某个基本 Monad 中。
Monad 变换器以较简单的 Monad 类型作为参数，返回增强的 Monad 类型。
至少，Monad 变换器应提供以下实例：
 1. 假设内部类型已经是 Monad 的 `Monad` 实例
 2. 将从内部 Monad 翻译为转换后的 Monad 的 `MonadLift` 实例
 
Monad 变换器可以作为多态结构或归纳数据类型实现，但通常将其实现为从底层 Monad 类型到增强 Monad 类型的函数。

## 效果的类型类

通常的设计模式是通过定义具有该效果的 Monad、向另一个 Monad 添加该效果的 Monad 变换器以及提供效果通用接口的类型类来实现特定效果。
这允许编写仅指定其所需效果的程序，以便调用者可以提供具有正确效果的任何 Monad。

有时，辅助类型信息（例如提供状态的 Monad 中的状态类型，或提供异常的 Monad 中的异常类型）是输出参数，有时则不是。
输出参数对于仅使用每种效果一次的简单程序最有用，但当一个给定程序中使用多个相同效果的实例时，它可能早早地使类型检查器承诺错误的类型。
因此，通常会提供两个版本，而带有普通参数的类型类的名称以“-Of”结尾。

## Monad 变换器不可交换

重要的是要注意，更改一个 Monad 中变换器的顺序可能会改变使用该 Monad 的程序的含义。
例如，重新排列 `StateT` 和 `ExceptT` 可能导致在抛出异常时丢失状态修改的程序，也可能导致保留更改的程序。
尽管大多数命令式语言只提供后者，但通过单子变换器提供的增加的灵活性要求我们仔细考虑选择正确的变体来完成手头的任务。

## 使用 Monad 变换器的 `do`-Notation

Lean的 `do`-块支持早期返回，即块会以某个值终止，具有局部可变的变量、带有 `break` 和 `continue` 的 `for`-循环以及单向分支的 `if`-语句。
虽然这看起来好像引入了会干扰使用Lean编写证明的命令式特性，但实际上它只是一种更方便的语法，用于某些常见的使用单子变换器的情况。
在幕后，`do`-块所写在的任何单子都会通过适当使用 `ExceptT` 和 `StateT` 进行变换，以支持这些附加的效果。