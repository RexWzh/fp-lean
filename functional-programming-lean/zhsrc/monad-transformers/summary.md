# 摘要

## 合并单子

当从头开始编写单子时，有一些设计模式往往描述了如何将每种效果添加到单子中。
通过将单子的类型设置为来自读取器环境的函数，可以添加读取效果；通过包含从初始状态到与最终状态配对的值的函数，可以添加状态效果；通过在返回类型中包含求和类型，可以添加失败或异常；通过在返回类型中包含乘积类型，可以添加日志或其他输出。
现有的单子也可以作为返回类型的一部分，从而使它们的效果包含在新的单子中。

通过定义 *单子变换器*，将这些设计模式制作成可重用的软件组件库。
单子变换器将简化的单子类型作为参数，返回增强的单子类型。
至少，单子变换器应该提供以下实例：
1. 一个 `Monad` 实例，假设内部类型已经是一个单子。
2. 一个 `MonadLift` 实例，将从内部单子转换为转换后的单子的操作。

单子变换器可以被实现为多态结构或归纳数据类型，但它们最常被实现为从底层单子类型到增强单子类型的函数。

## 用于效果的类型类

一个常见的设计模式是通过定义具有该效果的单子来实现特定的效果，通过定义一个将其添加到另一个单子的单子变换器，以及一个提供效果的通用接口的类型类。
这允许编写仅指定它们需要的效果的程序，所以调用者可以提供任何具有正确效果的单子。

有时，辅助类型信息（例如，为提供状态的单子的状态类型，或为提供异常的单子的异常类型）是一个输出参数，有时不是。
输出参数对于只使用一次每种效果的简单程序非常有用，但是当在给定的程序中使用多个相同效果的实例时，它会使类型检查器过早地选择错误类型。
因此，通常提供两个版本，类型类的普通参数版本以 `-Of` 结尾命名。

## 单子变换器不可交换

需要注意的是，更改单子中变换器的顺序可能会改变使用该单子的程序的含义。
例如，重新排列 `StateT` 和 `ExceptT` 可能导致在抛出异常时丢失状态修改的程序，也可能导致保留更改的程序。
虽然大多数命令式语言只提供后者，但是单子变换器提供的增加的灵活性需要思考和注意，以选择正确的变体来完成手头的任务。

## 使用 Monad 变换器的 `do`-Notation

Lean 的 `do`-块支持早期返回，在这种情况下，块会以某个值终止，还有局部可变变量、带有 `break` 和 `continue` 的 `for` 循环，以及带有单一分支的 `if` 语句。
虽然这似乎引入了会妨碍 Lean 进行证明的命令式特性，但实际上它只是一种更方便的语法，用于某些常见的单子变换器的使用。
在幕后，不管 `do`-块所在的单子是什么，都会通过适当使用 `ExceptT` 和 `StateT` 进行转换，以支持这些附加效果。