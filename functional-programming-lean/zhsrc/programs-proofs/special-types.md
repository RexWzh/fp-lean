# 特殊类型

理解内存中数据的表示非常重要。
通常，可以通过数据类型的定义来理解其表示。
每个构造函数对应着内存中的一个对象，该对象具有包含标签和引用计数的头部。
构造函数的参数由指向其他对象的指针表示。
换句话说，`List` 真的是一个链表，从 `structure` 提取字段确实只是追踪指针。

然而，有一些重要的例外情况。
编译器会特殊处理一些类型。
例如，类型 `UInt32` 被定义为 `Fin (2 ^ 32)`，但在运行时它会被实际的本地实现替换，该实现基于机器字。
类似地，尽管 `Nat` 的定义表明其实现类似于 `List Unit`，但实际的运行时表示使用了立即机器字（immediate machine words）来表示足够小的数字，并使用高效的任意精度算术库来表示较大的数字。
Lean 编译器会将使用模式匹配的定义转化为适合该表示的操作，并将加法和减法等操作调用映射到底层算术库中的快速操作。
毕竟，加法的时间复杂度不应该随着加数大小的增加而线性增加。

一些类型有特殊的表示方式意味着在使用它们时需要小心处理。
这些类型中的大多数是由编译器特殊处理的 `structure`。
对于这些结构，直接使用构造函数或字段访问器可能会触发一个昂贵的转换，将高效的表示转换为方便证明的慢表示。
例如，`String` 被定义为一个包含字符列表的结构，但字符串的运行时表示使用的是 UTF-8，而不是字符的指针链表。
将构造函数应用于字符列表会创建一个以 UTF-8 编码的字节数组，访问结构的字段会花费时间，与字符串长度成线性关系，以解码 UTF-8 表示并分配一个链接列表。
数组的表示方式类似。
从逻辑角度来看，数组是包含数组元素列表的结构，但运行时表示是一个动态大小的数组。
运行时，构造函数会将列表转换为数组，而字段访问器会从数组中分配一个链接列表。
编译器会用效率更高的版本替换各种数组操作，这些版本在可能的情况下会改变数组而不是分配一个新数组。
LENA 定理证明的文章的翻译：

编译后的代码中完全删除了类型本身和命题的证明。
换句话说，它们不占用任何空间，任何可能作为证明的一部分进行的计算也会被删除。
这意味着证明可以利用字符串和数组的方便接口作为归纳定义的列表，包括使用归纳法来证明与其相关的性质，而不会在程序运行时引入慢速转换步骤。
对于这些内置类型，方便的逻辑表示并不意味着程序必须慢。

如果一个结构类型只有一个非类型非证明字段，那么构造函数本身在运行时消失，被其单个参数替代。
换句话说，子类型和其基础类型的表示是相同的，而不是多了一层间接性。
同样，`Fin` 在内存中就是 `Nat`，可以创建具有不同用途的 `Nat` 或 `String` 的单字段结构，而不会付出性能代价。
如果构造函数没有非类型非证明参数，那么构造函数也消失，被常量值替代，否则将使用指针。
这意味着 `true`、`false` 和 `none` 是常量值，而不是指向堆分配对象的指针。

以下类型有特殊表示：

| 类型                                  | 逻辑表示                                                                                  | 运行时表示                                                                       |
|---------------------------------------|------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| `Nat`                                 | 一元，每个 `Nat.succ` 都有一个指针                                                          | 高效的任意精度整数                                                               |
| `Int`                                 | 和类型，包含正值或负值的构造函数，每个都包含一个 `Nat`                                       | 高效的任意精度整数                                                               |
| `UInt8`、`UInt16`、`UInt32`、`UInt64` | 具有适当上界的 `Fin`                                                                          | 固定精度的机器整数                                                               |
| `Char`                                | 一个 `UInt32`，配以一个证明它是有效码点的证明                                                  | 普通字符                                                                        |
| `String`                              | 一个包含 `List Char` 的结构，字段名为 `data`                                                 | UTF-8 编码的字符串                                                              |
| `Array α`                             | 一个包含 `List α` 的结构，字段名为 `data`                                                    | 打包的指向 `α` 值的指针的数组                                                   |
| `Sort u`                              | 一个类型                                                                                    | 完全被删除                                                                      |
# LEAN 定理证明的证明

LENA 是一门形式化证明语言，用于进行宣称、定理和证明的形式化描述。它用直观的自然推理和强大的可编程功能来表示证明，以及灵活和自动化的证明搜索程序。

在本练习中，我们将研究如何使用LEAN进行定理的证明，并通过定义新数据类型的实例来展示这一过程。

我们首先要证明的定理是：*对于任意的 `n` 和 `k`，如果 `n` 不等于 0，`k` 不等于 0，那么 `n + k` 不等于 0*。

我们可以使用如下表达式来表示这个定理：

```lean
theorem add_not_zero {n k : Nat} (h₁ : n ≠ 0) (h₂ : k ≠ 0) : n + k ≠ 0 :=
  -- proof goes here
```

在这个定理中，我们有两个参数 `n` 和 `k`，以及两个假设 `h₁` 和 `h₂`，分别表示 `n` 和 `k` 不等于 0。我们的目标是证明 `n + k` 不等于 0。

为了证明这个定理，我们可以使用自然推理的方法。根据 `Nat` 类型的定义，我们可以拆分 `n + k` 的三种可能情况：`n = 0`，`k = 0` 和 `n ≠ 0` 以及 `k ≠ 0`。

我们可以按照如下步骤进行证明：

1. 首先，我们可以使用 `cases` 证明策略来拆分 `n = 0` 和 `k = 0` 这两种情况。在每种情况下，我们可以使用 `contradiction` 策略来推导出矛盾，进而得出结论 `n + k ≠ 0`。
2. 接下来，我们需要证明 `n ≠ 0` 和 `k ≠ 0` 的情况，这是定理的主要部分。我们可以使用 `by_contra` 策略来假设 `n + k = 0`，并根据定义推导出 `n = 0` 或 `k = 0` 的矛盾。这将导致前一步中已经证明的情况。
3. 最后，我们可以使用 `finish` 策略来自动完成证明，根据之前的步骤，得出结论 `n + k ≠ 0`。