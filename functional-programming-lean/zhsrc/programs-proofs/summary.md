# 概述

## 尾递归

尾递归是一种递归的方式，递归调用的结果会立即返回，而不会在其他地方使用。
这些递归调用被称为 _尾调用_。
尾调用很有趣，因为它们可以被编译为跳转指令而不是调用指令，并且当前的栈帧可以被重用，而不是推入一个新的栈帧。
换句话说，尾递归函数实际上是循环。

提高递归函数速度的常见方法是将其重写为累加器传递方式。
不再使用调用栈来记住递归调用的结果是要执行的操作，而是使用一个额外的参数称为 _累加器_ 来收集这些信息。
例如，一个用于反转列表的尾递归函数的累加器包含已经看到的列表条目，以相反的顺序存储。

在 Lean 中，只有自己的尾调用被优化为循环。
换句话说，相互以尾调用方式结束的两个函数不会被优化。

## 引用计数和就地更新

Lean 不像 Java、C# 和大多数 JavaScript 实现那样使用追踪垃圾回收器，而是使用引用计数进行内存管理。
这意味着内存中的每个值都包含一个字段，用于跟踪有多少其他值引用它，并且运行时系统在引用的出现或消失时维护这些计数。
引用计数也在 Python、PHP 和 Swift 中使用。

当被要求分配一个新对象时，Lean 的运行时系统可以回收那些引用计数下降到零的现有对象。
此外，如果引用计数为1，数组操作（例如 `Array.set` 和 `Array.swap`）将会改变一个数组而不是分配一个修改后的副本。
如果 `Array.swap` 是对数组的唯一引用，那么程序的其他部分无法知道它是被修改还是复制的。

在 Lean 中编写高效的代码需要使用尾递归，并小心确保使用大型数组是唯一的。
虽然可以通过检查函数的定义来识别尾调用，但要理解一个值是否被唯一引用可能需要阅读整个程序。
调试助手 `dbgTraceIfShared` 可以在程序的关键位置使用，以检查一个值是否被共享。

## 证明程序的正确性

将程序重写为累加器传递方式，或者进行其他使其运行更快的转换，也可能使其更难理解。
保留更加清晰正确的程序的原始版本，并将其用作优化版本的可执行规范可能很有用。尽管像单元测试这样的技术在 Lean 中和其他语言一样有效，但 Lean 还可以使用完全确保两个函数版本对于所有可能的输入返回相同结果的数学证明。

通常，使用函数外延性（`funext`策略）来证明两个函数相等，它是这样的原则：如果两个函数对于每个输入返回相同的值，则它们是相等的。
如果函数是递归的，那么归纳通常是证明它们的输出相同的一个好办法。
通常，函数的递归定义会在一个特定的参数上进行递归调用；这个参数是归纳的一个很好的选择。
在某些情况下，归纳假设可能不够强大。
解决这个问题通常需要思考如何构建一个更一般的定理陈述，以提供足够强大的归纳假设。
特别是，为了证明一个函数等价于一个传递累加器版本，需要一个定理陈述来将任意初始累加器值与原始函数的最终结果联系起来。

## 安全的数组索引

类型 `Fin n` 表示严格小于 `n` 的自然数。
`Fin` 是 "finite" 的缩写。
与子类型一样，`Fin n` 是一个包含 `Nat` 的结构，并且证明了该 `Nat` 小于 `n`。
类型 `Fin 0` 没有取值。

如果 `arr` 是一个 `Array α`，那么 `Fin arr.size` 总是包含一个适当的索引值，可以用于 `arr`。
许多内置数组操作符，如 `Array.swap`，接受 `Fin` 值作为参数，而不是单独的证明对象。

Lean 为 `Fin` 提供了大多数有用的数值类型类的实例。
`Fin` 的 `OfNat` 实例执行模运算，而不是在编译时失败，如果提供的数字大于 `Fin` 可接受的大小。

## 临时证明

有时，假装一个陈述已证明而没有实际进行证明的工作可能很有用。
当确保一个陈述的证明对于某些任务是适合的时候，比如在另一个证明中进行重写，确定一个数组访问是安全的，或者证明递归调用是在比原始参数更小的值上进行的时候，这是非常有用的。
证明某事物花费了大量时间，但却发现其他证明可能更有用，这是非常令人沮丧的。

`sorry` 策略使 Lean 暂时接受一个陈述，就像 C# 中抛出 `NotImplementedException` 的存根方法一样。
任何依赖于 `sorry` 的证明在 Lean 中都包含一个警告。

要小心！
`sorry` 策略可以证明_任何_陈述，甚至是错误的陈述。
证明 `3 < 2` 可能导致越界数组访问在运行时继续存在，意外地导致程序崩溃。
在开发过程中使用 `sorry` 很方便，但在代码中保留它是危险的。

## 证明终止性

当一个递归函数不使用结构递归时，Lean 无法自动确定它的终止性。
在这些情况下，该函数可以被标记为 `partial`。
然而，还可以提供一个证明，证明该函数终止。

部分函数有一个关键的缺点：它们不能在类型检查或证明中展开。
这意味着 Lean 作为一个交互式定理证明器的价值无法应用于它们。
此外，证明一个预期会终止的函数实际上确实总是终止，可以消除更多潜在的错误源。

`termination_by` 子句允许在函数末尾指定递归函数终止的原因。
该子句将函数的参数映射到一个表达式，每次递归调用都期望该表达式更小。
一些可能减小的表达式的例子是数组中一个不断增长的索引与数组的大小之间的差异，每次递归调用时被切成一半的列表的长度，或者一对列表，恰好只有一个列表在每次递归调用时缩小。

Lean 包含可以自动确定某些表达式在每次调用时都会减小的证明自动化，但许多有趣的程序将需要手动证明。
这些证明可以使用 `have` 来提供，`have` 是 `let` 的一种版本，用于局部提供证明而不是值。

编写递归函数的一种好方式是首先将它们声明为 `partial`，并通过测试调试它们，直到它们返回正确的答案。
然后，可以移除 `partial` 并替换为 `termination_by` 子句。
Lean 将在每次递归调用上放置错误高亮，需要提供一个包含需要证明的陈述的证明的地方。
这些陈述可以放在 `have` 中，证明则使用 `sorry`。
如果 Lean 接受了程序并且它仍然通过了测试，最后一步是实际证明使 Lean 能够接受它的定理。
这种方法可以避免浪费时间来证明有错误的程序会终止。