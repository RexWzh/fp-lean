# 尾递归

虽然 Lean的 `do` 表达式使得使用传统的循环语法（如 `for` 和 `while`）成为可能，但这些结构在幕后会被转换为对递归函数的调用。
在大多数编程语言中，递归函数相较于循环函数有一个关键的劣势：循环不会消耗堆栈空间，而递归函数的堆栈消耗与递归调用的次数成正比。
堆栈空间通常是有限的，因此往往需要将自然表达为递归函数的算法重写为循环加上显式可变的堆栈分配。

在函数式编程中，情况通常正好相反。
以可变循环的方式表达的程序可能会消耗堆栈空间，而将它们重写为递归函数可以提高其运行速度。
这是因为函数式编程语言的一个关键特性：**尾递归消除**。
尾调用是从一个函数到另一个函数的调用，可以被编译为普通的跳转，替换当前的堆栈帧而不是推入一个新的堆栈帧，尾递归消除就是实现了这一转换的过程。

尾递归消除不仅仅是一种可选的优化。
它的存在是编写高效函数式代码的基本要素。
为了能够使用，它必须是可靠的。
程序员必须能够可靠地识别尾调用，并且必须能够信任编译器会将其消除。

`NonTail.sum` 函数用于将一个 `Nat` 类型的列表中的所有元素相加：

```lean
{{#example_decl Examples/ProgramsProofs/TCO.lean NonTailSum}}
```

将该函数应用于列表 `[1, 2, 3]`，得到以下求值步骤的序列：

1. `(λx.x) ((λy.y) 1) ((λz.z) 2) ((λw.w) 3)`
2. `(λx.x) (λy.y) ((λz.z) 2) ((λw.w) 3)`   将 `1` 替换进第一个参数位置
3. `(λx.x) (λy.y) (λz.z) ((λw.w) 3)`   将 `2` 替换进第二个参数位置
4. `(λx.x) (λy.y) (λz.z) (λw.w)`   将 `3` 替换进第三个参数位置
5. `(λy.y) (λz.z) (λw.w)`   将 `(λx.x)` 全部替换为 `(λy.y)`
6. `(λz.z) (λw.w)`   将 `(λy.y)` 全部替换为 `(λz.z)`
7. `(λw.w)`   将 `(λz.z)` 全部替换为 `(λw.w)`
8. `(λw.w)`   最终结果为 `(λw.w)` ，即标识函数。

```lean
{{#example_eval Examples/ProgramsProofs/TCO.lean NonTailSumOneTwoThree}}
```

在评估的步骤中，括号表示对 `NonTail.sum` 的递归调用。
换句话说，为了将这三个数相加，程序必须首先检查列表是否非空。
为了将列表的头部（`1`）与列表的尾部的和相加，必须首先计算列表的尾部的和：

```lean
{{#example_eval Examples/ProgramsProofs/TCO.lean NonTailSumOneTwoThree 1}}
```

但是要计算列表的尾部之和，程序必须检查它是否为空。
它不是空的-列表的尾部本身就是一个以 `2` 为首元素的列表。
得到的步骤等待 `NonTail.sum [3]` 的返回：

```lean
{{#example_eval Examples/ProgramsProofs/TCO.lean NonTailSumOneTwoThree 2}}
```

整个运行时调用栈的目的是跟踪值`1`、`2`和`3`，以及将它们与递归调用的结果相加的指令。
随着递归调用的完成，控制权返回到进行调用的栈帧，因此每一步的加法都会执行。
存储列表的头部和将它们相加的指令并不是免费的，它需要与列表的长度成比例的空间。

函数`Tail.sum`还会将`Nat`类型列表中的内容相加：

```lean
{{#example_decl Examples/ProgramsProofs/TCO.lean TailSum}}
```

将该定理应用于列表 `[1, 2, 3]` 得到以下的求值步骤序列：

```lean
{{#example_eval Examples/ProgramsProofs/TCO.lean TailSumOneTwoThree}}
```

内部辅助函数在递归调用自身时，采用的是一种不需要记住任何东西就可以计算出最终结果的方式。

当 `Tail.sumHelper` 达到基本情况时，控制权可以直接返回给 `Tail.sum`，因为 `Tail.sumHelper` 的中间调用只是原样返回其递归调用的结果。

换句话说，每个递归调用 `Tail.sumHelper` 只需要重新使用单个栈帧。尾调用消除就是对栈帧的重新使用，而 `Tail.sumHelper` 被称为尾递归函数。

`Tail.sumHelper` 的第一个参数包含了在调用栈中需要跟踪的所有信息，即迄今为止遇到的数字的总和。在每个递归调用中，这个参数会被更新为新的信息，而不是将新信息添加到调用栈中。像 `soFar` 这样替代调用栈信息的参数被称为累加器。

目前为止在作者的计算机上测试，当以包含 216,856 个或更多条目的列表作为参数传递给 `NonTail.sum` 时，它会导致堆栈溢出。然而，`Tail.sum` 可以对含有 100,000,000 个元素的列表进行求和而不会发生堆栈溢出。这是因为执行 `Tail.sum` 时不需要推入新的堆栈帧，它完全等效于一个使用可变变量来保存当前列表的 `while` 循环。在每次递归调用中，堆栈上的函数参数只是被下一个列表节点替换。

## 尾部和非尾部位置

`Tail.sumHelper` 是尾递归的原因在于递归调用处于"尾部位置"。简单地说，如果调用者不需要以任何方式修改返回值，而是直接返回它，那么函数调用就处于尾部位置。更具体地，可为表达式明确定义尾部位置。

如果一个 `match`-表达式位于尾部位置，则它的每个分支也处于尾部位置。一旦 `match` 选择了一个分支，控制权立即转移到该分支上。类似地，如果 `if`-表达式本身处于尾部位置，那么它的两个分支也处于尾部位置。最后，如果一个 `let`-表达式处于尾部位置，则它的主体也处于尾部位置。

其他所有位置都不处于尾部位置。
函数或构造函数的参数不在尾部位置，因为计算必须跟踪将被应用于参数值的函数或构造函数。

内部函数的主体不在尾部位置，因为控制甚至可能不会传递给它：函数主体在函数被调用之前不会被评估。

同样，函数类型的主体也不在尾部位置。为了评估在 `(x : α) → E` 中的 `E`，需要跟踪结果类型必须被 `(x : α) → ...` 包裹。

在 `NonTail.sum` 中，递归调用不在尾部位置，因为它是 `+` 的一个参数。

在 `Tail.sumHelper` 中，递归调用在尾部位置，因为它直接位于模式匹配的下方，而模式匹配本身是函数的主体。

在撰写本文时，Lean 只消除递归函数中的直接尾调用。这意味着对于函数 `f` 的定义中的对 `f` 的尾调用将被消除，但对其他函数 `g` 的尾调用不会被消除。虽然可以消除对其他函数的尾调用，从而节省一帧栈空间，但这在 Lean 中尚未实现。

## 反转列表

函数 `NonTail.reverse` 通过将每个子列表的头部追加到结果的末尾来反转列表：

```lean
{{#example_decl Examples/ProgramsProofs/TCO.lean NonTailReverse}}
```

使用它来反转 `[1, 2, 3]` 的结果如下所示的步骤序列：

1. *初始化*：设置输入列表为 `[1, 2, 3]` ，创建一个空的输出列表 `[]` ，设置计数器 `i` 为 0 。
2. *循环开始*：检查计数器 `i` 是否小于输入列表的长度（3），是的话继续执行下一步，否则退出循环。
3. *获取元素*：获取输入列表中索引为 `i` 的元素，并将其赋值给变量 `x` 。在第一次迭代中， `x` 的值为 1 。
4. *插入元素*：在输出列表的第一个位置插入元素 `x` ，即 `[1]` 。
5. *更新计数器*：将计数器 `i` 的值增加 1 ，现在 `i` 的值为 1 。
6. *循环开始*：检查计数器 `i` 是否小于输入列表的长度（3），是的话继续执行下一步，否则退出循环。
7. *获取元素*：获取输入列表中索引为 `i` 的元素，并将其赋值给变量 `x` 。在第二次迭代中， `x` 的值为 2 。
8. *插入元素*：在输出列表的第一个位置插入元素 `x` ，即 `[2, 1]` 。
9. *更新计数器*：将计数器 `i` 的值增加 1 ，现在 `i` 的值为 2 。
10. *循环开始*：检查计数器 `i` 是否小于输入列表的长度（3），是的话继续执行下一步，否则退出循环。
11. *获取元素*：获取输入列表中索引为 `i` 的元素，并将其赋值给变量 `x` 。在第三次迭代中， `x` 的值为 3 。
12. *插入元素*：在输出列表的第一个位置插入元素 `x` ，即 `[3, 2, 1]` 。
13. *更新计数器*：将计数器 `i` 的值增加 1 ，现在 `i` 的值为 3 。
14. *循环开始*：检查计数器 `i` 是否小于输入列表的长度（3），不是的话退出循环。
15. *输出结果*：返回输出列表 `[3, 2, 1]` 作为反转后的结果。

完成以上步骤后，输入列表 `[1, 2, 3]` 被反转为输出列表 `[3, 2, 1]`。

```lean
{{#example_eval Examples/ProgramsProofs/TCO.lean NonTailReverseSteps}}
```

尾递归版本在每一步的累加器上使用 `x :: ·` 而不是 `· ++ [x]` ：

```lean
{{#example_decl Examples/ProgramsProofs/TCO.lean TailReverse}}
```

这是因为在计算 `NonTail.reverse` 时，保存在每个栈帧中的上下文是从基本情况开始执行的。
每个“记住”的上下文按照后进先出的顺序执行。
另一方面，累加器传递版本从列表的第一个条目开始修改累加器，而不是原始的基本情况，可以在一系列简化步骤中看到这一点：

```lean
{{#example_eval Examples/ProgramsProofs/TCO.lean TailReverseSteps}}
```

换句话说，非尾递归版本从基本情况开始，在整个列表中从右到左修改递归的结果。列表中的条目以先进先出的顺序影响累加器。带累加器的尾递归版本从列表的开头开始，在整个列表中从左到右修改初始累加器值。

因为加法是可交换的，因此在 `Tail.sum` 中不需要做任何处理来考虑这一点。追加列表不是可交换的，所以必须注意找到一种在相反方向运行时具有相同效果的操作。在 `NonTail.reverse` 的递归结果之后追加 `[x]` 相当于在将结果按相反顺序构建时在列表的开头添加 `x`。

## 多个递归调用

在 `BinTree.mirror` 的定义中，存在两个递归调用：

```lean
{{#example_decl Examples/Monads/Conveniences.lean mirrorNew}}
```

正如命令式语言通常会在函数 `reverse` 和 `sum` 中使用 while 循环，它们通常会在这种遍历中使用递归函数。

这个函数不能简单地使用累加器传递风格重新编写成尾递归。

通常，如果每个递归步骤需要多个递归调用，那么使用累加器传递风格将会很困难。
这个困难类似于将一个递归函数重写为使用循环和显式数据结构的困难，而且还需要说服 Lean 函数终止。
然而，就像 `BinTree.mirror` 中那样，多个递归调用经常表示一个具有多个其自身的递归出现的构造函数。
在这些情况下，结构的深度通常是相对于其总体大小对数级别的，这使得堆栈和堆之间的权衡不那么激烈。
有一些系统化的技巧可以使这些函数成为尾递归，比如使用*延续传递风格*，但这超出了本章的范围。

## 练习题

将以下每个非尾递归函数转换为累加器传递的尾递归函数：

```lean
{{#example_decl Examples/ProgramsProofs/TCO.lean NonTailLength}} 
```



```lean
{{#example_decl Examples/ProgramsProofs/TCO.lean NonTailFact}}
```

`NonTail.filter`的翻译应该得到一个通过尾递归占用常数栈空间的程序，并且时间复杂度与输入列表的长度成线性关系。与原始程序相比，接受一个常数因子的开销是可以接受的：

```lean
{{#example_decl Examples/ProgramsProofs/TCO.lean NonTailFilter}}
```

