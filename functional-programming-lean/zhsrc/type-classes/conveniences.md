# 附加便利功能

## 实例的构造函数语法

在幕后，类型类是结构类型，实例是这些类型的值。
唯一的区别在于 Lean 存储了关于类型类的附加信息，比如哪些参数是输出参数，并且实例被注册用于搜索。
虽然通常使用 `⟨...⟩` 语法或者花括号和字段来定义有结构类型的值，使用 `where` 来定义实例，但这两种语法都适用于两种定义方式。

例如，一个林业应用可能如下表示树：

```lean
{{#example_decl Examples/Classes.lean trees}}
```

所有三种语法是等价的。

同样地，类型类实例可以使用任意一种语法来定义：

```lean
{{#example_decl Examples/Classes.lean Display}}
```

通常来说，`where` 语法应该用于实例，而花括号语法应该用于结构体。
`⟨...⟩` 语法在强调结构体类型与元组非常相似但字段名称并不重要的情况下非常有用。
然而，有些情况下使用其他替代方案可能更合适。
特别是，一个库可能会提供一个构造实例值的函数。
在实例声明的 `:=` 后面放置一个调用该函数的表达式是使用这种函数的最简单的方法。

## 例子

当尝试编写 Lean 代码时，使用定义比 `#eval` 或 `#check` 命令更方便。
首先，定义不会产生任何输出，这有助于让读者关注最有趣的输出。
其次，通过从类型签名开始编写大多数 Lean 程序是最简单的，这样 Lean 在编写程序本身时能够提供更多的帮助和更好的错误提示。
另一方面，`#eval` 和 `#check` 在 Lean 能够根据提供的表达式确定类型的上下文中使用最简单。
第三，`#eval` 无法用于那些类型没有 `ToString` 或 `Repr` 实例的表达式，比如函数。
最后，多步骤的 `do` 块、`let` 表达式和其他需要多行的语法形式在 `#eval` 或 `#check` 中使用类型注释时特别难写，因为所需的括号化可能很难预测。

为了解决这些问题，Lean 支持在源文件中显式指示例子。
一个例子就像一个没有名字的定义。
例如，可以这样写一个非空列表，其中包含哥本哈根公共绿地上常见的鸟类：

```lean
{{#example_decl Examples/Classes.lean birdExample}}
```

例子可以通过接受参数来定义函数：

```lean
def add (x y : ℕ) : ℕ :=
  x + y

def hello (name : string) : string :=
  "Hello, " ++ name
```

在这个例子中，我们定义了两个函数 `add` 和 `hello`。`add` 函数接受两个自然数作为参数，并返回它们的和。而 `hello` 函数接受一个字符串作为参数，并返回一个拼接了问候语的字符串。

```lean
{{#example_decl Examples/Classes.lean commAdd}}
```

尽管这在幕后创建了一个函数，但这个函数没有名字，也不能被调用。
尽管如此，这对于展示如何在给定类型的任意或未知值中使用库非常有用。
在源文件中，`example` 声明最好与解释库概念的注释相配合。