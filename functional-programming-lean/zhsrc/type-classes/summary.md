# 概述

## 类型类和重载

类型类是 Lean 中用于函数和运算符重载的机制。
多态函数可以使用多个类型，但它的行为不会随着使用的类型的不同而改变。
例如，一个能将两个列表连接的多态函数可以使用任何类型的列表，但它不能根据找到的特定类型的不同而有不同的行为。
另一方面，使用类型类进行重载的操作也可以使用多个类型。
但是，每个类型都需要自己的重载操作的实现。
这意味着行为可以根据提供的类型的不同而有所变化。

一个_类型类_有一个名称、参数和一个由一些具有类型的名字组成的主体。
名称是引用重载操作的方式，参数确定哪些定义的方面可以重载，主体提供了可重载操作的名字和类型签名。
每个可重载操作都被称为类型类的一个_方法_。
类型类可以在其他方法的基础上提供一些方法的默认实现，当不需要手动定义每个重载时，这一点可以使实现者从中获得自由。

类型类的_实例_为给定的参数提供了方法的实现。
实例可以是多态的，这样它们可以适用于各种参数，并且在某些特定类型存在更高效的版本时，它们还可以选择性地提供更具体的默认方法的实现。

类型类参数可以是_输入参数_（默认）或_输出参数_（通过 `outParam` 修饰符指示）。
只有当所有的输入参数不再是元变量时，Lean 才会开始搜索实例，而输出参数可以在搜索实例时解决。
类型类的参数不必是类型，它们也可以是普通的值。
用于重载自然数字面值的 `OfNat` 类型类将自身作为参数，允许实例限制所允许的数字。

实例可以使用 `@[default_instance]` 属性进行标记。
当一个实例是默认实例时，它会被选择为 Lean 在类型中存在元变量的情况下无法找到实例时的备选方案。

## 通用语法的类型类

Lean 中的大多数中缀操作符都使用了类型类的重载。
例如，加法操作符对应的类型类是 `Add`。
大多数这些操作符都有对应的异构版本，其中两个参数的类型不需要相同。
这些异构操作符是使用以 `H` 开头的类的版本进行重载的，比如 `HAdd`。

索引语法使用一个名为 `GetElem` 的类型类进行重载，其中涉及到一些证明。
`GetElem` 有两个输出参数，分别是要从集合中提取的元素的类型和一个可以用来确定索引值是否在集合的范围内的函数。
这个证据由一个命题描述，而 Lean 在使用数组索引时会尝试证明这个命题。
当 Lean 在编译时无法检查到列表或数组访问操作是否在边界内时，可以通过在索引操作后面添加一个 `?` 来延迟到运行时进行检查。

## 函子

函子是支持映射操作的多态类型。
这个映射操作在原地改变所有元素，不改变任何其他结构。
例如，列表就是函子，映射操作既不会丢弃、复制，也不会打乱列表中的条目。

虽然函子是通过拥有 `map` 来定义的，但是 Lean 中的 `Functor` 类型类包含了一个额外的默认方法，负责在一个值上映射常数函数，将所有类型与多态类型变量给定的相同新值的值替换。
对于一些函子来说，这可以比遍历整个结构更高效地完成。

## 导出实例

许多类型类都有非常标准的实现。
例如，布尔等式类 `BEq` 通常通过首先检查两个参数是否使用相同的构造函数，然后检查它们所有的参数是否相等来实现。
可以 _自动_ 创建这些类的实例。

当定义归纳类型或结构时，在声明的末尾加上一个 `deriving` 子句将自动创建实例。
此外，可以在数据类型的定义之外使用 `deriving instance ... for ...` 命令来生成实例。
因为每个可以派生实例的类都需要特殊处理，所以并非所有的类都可以进行项导出实例。

## 强制转换

强制转换允许 Lean 在通常会导致编译时错误的情况下，通过插入一个将数据从一种类型转换为另一种类型的函数调用来恢复。
例如，从任意类型 `α` 到类型 `Option α` 的强制转换允许直接编写值，而不是使用 `some` 构造函数，使得 `Option` 的工作更像面向对象语言中的可空类型。
有多种类型的强制转换。
它们可以从不同的错误中恢复，每种错误都由自己的类型类表示。
`Coe` 类用于从类型错误中恢复。
当 Lean 在上下文中期望某个类型为 `β` 的东西时，它首先尝试将一系列强制转换链接起来，将 `α` 转换为 `β`，只有当无法转换时才显示错误。
`CoeDep` 类将被转换的具体值作为额外参数，可以在该值上进行进一步的类型类搜索，或者允许在实例中使用构造函数来限制转换的范围。
`CoeFun` 类在编译函数应用时，截获原本会出现的“不是函数”错误，并且如果可能的话，允许将函数位置上的值转换为实际的函数。